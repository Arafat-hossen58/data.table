require(methods)
if (exists("test.data.table", .GlobalEnv, inherits=FALSE)) {
  if ((tt<-compiler::enableJIT(-1))>0)
    cat("This is dev mode and JIT is enabled (level ", tt, ") so there will be a brief pause around the first test.\n", sep="")
} else {
  require(data.table)
  test = data.table:::test
  is.AsIs = data.table:::is.AsIs
}

# AsIs
test(1.01, is.AsIs(1L), FALSE)
test(1.02, is.AsIs(I(1L)), TRUE)
test(1.03, is.AsIs("a"), FALSE)
test(1.04, is.AsIs(I("a")), TRUE)
test(1.05, is.AsIs(list(1L)), FALSE)
test(1.06, is.AsIs(I(list(1L))), TRUE)
test(1.07, is.AsIs(structure(list(NULL), class="an_S3")), FALSE) ## S3
test(1.08, is.AsIs(I(structure(list(NULL), class="an_S3"))), TRUE)
test(1.09, is.AsIs(getClass("MethodDefinition")), FALSE) ## S4
test(1.10, is.AsIs(I(getClass("MethodDefinition"))), TRUE)

# substitute2 simple
test(2.01, substitute2(list(var = val), env = list(var="my_var", val=5L)), quote(list(my_var = 5L)))
# substitute2 + I to handle char and symbol
test(2.02, substitute2(list(var = val), env = list(var="my_var", val=I("my_val"))), quote(list(my_var="my_val")))
test(2.03, substitute2(list(var = val), env = I(list(var=as.name("my_var"), val="my_val"))), quote(list(my_var="my_val")))
# substitute2 handle symbol anyway
test(2.04, substitute2(list(var = val), env = list(var=as.name("my_var"), val=I("my_val"))), quote(list(my_var="my_val")))
# substitute2 complex use case
test(2.11, substitute2(
  .(fun_ans_var = fun(farg1, farg2=farg2val), timestamp=Sys.time(), col_head = head(head_arg, n=1L)),
  list(
    fun_ans_var = "my_mean_res",
    fun = "mean",
    farg1 = "my_x_col",
    farg2 = "na.rm",
    farg2val = TRUE,
    col_head = "first_y",
    head_arg = "y"
  )
), quote(.(my_mean_res=mean(my_x_col, na.rm=TRUE), timestamp=Sys.time(), first_y=head(y, n=1L))))
# substitute2 PR example
test(2.12, substitute2(
  .(out_col_name = fun(in_col_name, fun_arg1=fun_arg1val)),
  env = list(
    in_col_name = "x",
    fun = "sum",
    fun_arg1 = "na.rm",
    fun_arg1val = TRUE,
    out_col_name = "sum_x"
  )
), quote(.(sum_x = sum(x, na.rm=TRUE))))
# substitute2 nested calls
test(2.13, substitute2(f1(a1 = f2(a2 = f3(a3 = f4(a4 = v1, extra=v2), v3, a3b = v4)), a1b=c("a","b")), list(f1="fun1", f2="fun2", f3="fun3", f4="fun4", a1="arg1", a2="arg2", a3="arg3", a4="arg4", v1="col1", extra="n", v2=6L, v3="col2", a3b="arg3b", v4=c(3.5,4.5), a1b="arg1b")), substitute(fun1(arg1 = fun2(arg2 = fun3(arg3 = fun4(arg4 = col1, n=6L), col2, arg3b = v4)), arg1b=c("a","b")), list(v4=c(3.5,4.5))))
# calls of length 0 args
const1 = function() 1L
test(2.21, substitute2(list(nm = fun()), env=list(a="b", fun="const1", nm="int1")), quote(list(int1=const1())))
test(2.22, substitute2(.(), env=list(a="b", fun="const1", nm="int1")), quote(.()))
# substitute2 AsIs class properly removed or kept
test(2.31, class(substitute2(var3%in%values, list(var3="a", values=I(c("a","b","c"))))[[3L]]), "character")
test(2.32, class(substitute2(var3%in%values, I(list(var3=as.name("a"), values=c("a","b","c"))))[[3L]]), "character")
test(2.33, class(substitute2(var3%in%values, list(var3="a", values=I(1:3)))[[3L]]), "integer")
test(2.34, class(substitute2(var3%in%values, I(list(var3=as.name("a"), values=c(1:3))))[[3L]]), "integer")
qc = substitute2(var3%in%values, I(list(var3=as.name("a"), values=I(c("a","b","c"))))) ## keeping AsIs by extra I on whole env arg
test(2.35, qc, substitute(a %in% .v, list(.v=I(c("a","b","c")))))
test(2.36, class(qc[[3L]]), "AsIs")
qc = substitute2(var3%in%values, I(list(var3="a", values=I(1:3))))
test(2.37, qc, substitute("a" %in% .v, list(.v=I(1:3))))
test(2.38, class(qc[[3L]]), "AsIs")
# substitute2 non-scalar char as name
test(2.41, substitute2(list(var = val), env = list(var="my_var", val=c("a","b"))), error="are not scalar")
test(2.42, substitute2(list(var = val), env = list(var="my_var", val=I(c("a","b")))), substitute(list(my_var=.v), list(.v=c("a","b")))) ## note that quote(list(my_var=c("a","b")))) will not work because 'c("a","b")' will be a 'language' class (a 'c()' call), but we need to have it as 'character' class instead
test(2.43, substitute2(list(var = val), env = I(list(var=as.name("my_var"), val=c("a","b")))), substitute(list(my_var=.v), list(.v=c("a","b"))))
# substitute2 non-symbol
test(2.44, substitute2(list(var = val), env = list(var=I("my_var"), val="my_val")), error="type 'character' but it has to be 'symbol'")
test(2.45, substitute2(list(var = val), env = I(list(var="my_var", val="my_val"))), error="type 'character' but it has to be 'symbol'")
test(2.46, substitute2(.(v1=v2), list(v1=1L, v2=2L)), error="type 'integer' but it has to be 'symbol'")
test(2.47, substitute2(.(v1=v2), list(v1=FALSE, v2=2L)), error="type 'logical' but it has to be 'symbol'")
# substitute2 NA_character_ becomes valid 'NA' name
test(2.48, substitute2(.(v1 = v2), list(v1 = NA_character_, v2 = NA_character_, "." = "list")), quote(list(`NA` = `NA`)))
qc = substitute2(.(v1 = v2), list(v1 = NA_character_, v2 = I(NA_character_), "." = "list"))
test(2.49, qc, quote(list(`NA` = NA_character_)))
test(2.50, eval(qc), list("NA" = NA_character_))
# substitute2 duplicate matches
test(2.51, substitute2(list(v1=v2, v1=v2), env=list(v1="nm",v2=2L,v3=3L)), quote(list(nm = 2L, nm = 2L)))
test(2.52, substitute2(list(v1=v2, v1=v3), env=list(v1="nm",v2=2L,v3=3L)), quote(list(nm = 2L, nm = 3L)))
# substitute2 nested unnamed call
test(2.53, substitute2(c(list(v1=v2, v1=v2)), env=list(v1="nm",v2=2L,v3=3L)), quote(c(list(nm = 2L, nm = 2L))))
test(2.54, substitute2(c(list(v1=v2, v1=v3)), env=list(v1="nm",v2=2L,v3=3L)), quote(c(list(nm = 2L, nm = 3L))))
# TODO substitute2 during join

# substitute2 env as environment class
env = as.environment(list(v=1L, .v=2L))
test(2.81, substitute2(.(v, .v), env), quote(.(1L, 2L)))
# substitute2 invalid 'env' error coverage
test(2.91, substitute2(.()), error="TODO, as of now 'env' should not be missing") ## TODO
test(2.92, substitute2(v, c(v=1L)), error="'env' must be a list or an environment")
test(2.93, substitute2(.(v), list(1L, 2L)), error="'env' argument does not have names")
test(2.94, substitute2(.(v), structure(list(1L,2L), names=c("","v"))), error="'env' argument has zero char names")
test(2.95, substitute2(.(v), structure(list(1,2), names=c(NA,"v"))), error="'env' argument has NA names")
test(2.96, substitute2(.(v), list(v=1,v=2)), error="'env' argument has duplicated names")

# substitute2 re-use inside another function
f = function(expr, env) {
  eval(substitute(
    substitute2(.expr, env),
    list(.expr = substitute(expr))
  ))
}
qc = f(
  .(out_col_name = fun(in_col_name, fun_arg1=fun_arg1val)),
  env = list(
    in_col_name = "x",
    fun = "sum",
    fun_arg1 = "na.rm",
    fun_arg1val = TRUE,
    out_col_name = "sum_x"
  )
)
test(3.01, qc, quote(.(sum_x = sum(x, na.rm = TRUE))))
# substitute2 nested re-use inside another function
qc = substitute2(list(nm = fun(.(out_col_name = fun(in_col_name, fun_arg1=fun_arg1val)),
  env = list(
    in_col_name = "x",
    fun = "sum",
    fun_arg1 = "na.rm",
    fun_arg1val = tf_var, ## note a parameter here
    out_col_name = "sum_x"
))), list(nm="my_call", fun="f", tf_var=FALSE))
test(3.02, eval(qc), list(my_call = quote(.(sum_x = sum(x, na.rm = FALSE)))))

# data.table i, j, by
d = data.table(a = 2:1, b = 1:4)
test(4.01, d[var3%in%values, .(var1 = f(var2)), by=var3,
  env=list(var1="res", var2="b", f="sum", var3="a", values=0:3),
  verbose=TRUE], data.table(a=c(2L,1L), res=c(4L,6L)), output=c("Argument 'by' after substitute: a","Argument 'j'  after substitute: .(res = sum(b))","Argument 'i'  after substitute: a %in% 0:3")) # 0:3 is not expanded even when we use c(0L,1L,2L,3L), see `substitute(v+x, list(x=c(1L,2L)))` vs `substitute(v+x, list(x=c(0L,2L)))`
# data.table symbols and chars
d = data.table(a = c("b","a"), b = 1:4)
out = capture.output(ans <- d[var3%in%values, .(var1 = f(var2)), keyby=var3,
  env=list(var1="res", var2="b", f="sum", var3="a", values=I(c("a","b","c"))),
  verbose=TRUE]) # could not use output arg in test, so test it manually
test(4.02, ans, data.table(a=c("a","b"), res=c(6L,4L), key="a"))
out = grep("Argument.*substitute", out, value=TRUE)
test(4.021, length(out), 3L) # we expect i, j, by only here, ensure about that
test(4.022, as.logical(grep("Argument 'by' after substitute: a", out, fixed=TRUE)), TRUE)
test(4.023, as.logical(grep("Argument 'j'  after substitute: .(res = sum(b))", out, fixed=TRUE)), TRUE)
test(4.024, as.logical(grep("Argument 'i'  after substitute: a %in% c(\"a\", \"b\", \"c\")", out, fixed=TRUE)), TRUE)
out = capture.output(ans <- d[var3%in%values, .(var1 = f(var2)), keyby=var3,
  env=I(list(var1=as.name("res"), var2=as.name("b"), f=as.name("sum"), var3=as.name("a"), values=c("b","c"))),
  verbose=TRUE])
out = grep("Argument.*substitute", out, value=TRUE)
test(4.03, ans, data.table(a=c("b"), res=c(4L), key="a"))
test(4.031, length(out), 3L)
test(4.032, as.logical(grep("Argument 'by' after substitute: a", out, fixed=TRUE)), TRUE)
test(4.033, as.logical(grep("Argument 'j'  after substitute: .(res = sum(b))", out, fixed=TRUE)), TRUE)
test(4.034, as.logical(grep("Argument 'i'  after substitute: a %in% c(\"b\", \"c\")", out, fixed=TRUE)), TRUE)

# TODO special symbols
#".SD"
#".N", ".EACHI"
#I(list(j=as.name(".SD")))
#I(list(j=as.name(".N"), by=as.name(".EACHI")))

# get and mget use cases
d = as.data.table(lapply(1:5, rep, 2L))
setnames(d, paste0("c",1:5))
v1 = "c1"; v2 = "c2"; v3 = "c3"; v4 = "c4"; v5 = "c5"
### TODO report/review get-mget issues
## note that d[, get(v1)] is wrong here, it translates to d[, c1] while it should be d[, "c1"]
## d[, mget(v1)] is handling that fine, compare both! might have been used for convenience but it breaks consistency
test(4.051, d[, v1, env=list(v1=v1)], c(1L,1L))                          ## symbol c1
test(4.052, d[, v1, env=list(v1=I(v1))], data.table(c1=c(1L,1L)))        ## character "c1"
test(4.053, d[, v1, env=list(v1=I(v1))], d[, mget(v1)])                  ## character "c1", works against mget only
test(4.054, d[, v1v2, env=list(v1v2=I(c(v1,v2)))], d[, mget(c(v1, v2))]) ## character c("c1","c2")
test(4.055, d[, .(v1), env=list(v1=v1)], data.table(c1=c(1L,1L)))                        ## d[, .(get(v1))] - (m)get would return unnamed columns
test(4.056, d[, .(v1, v2), env=list(v1=v1, v2=v2)], data.table(c1=c(1L,1L),c2=c(2L,2L))) ## d[, .(get(v1), get(v2))]
test(4.057, d[, .(sum(v1)), env=list(v1=v1)], d[, .(sum(get(v1)))])
test(4.058, d[, lapply(vN, sum), env=list(vN=substitute2(list(v1=v1, v3=v3), list(v1=v1, v3=v3)))], d[, lapply(mget(c(v1,v3)), sum)])
test(4.059, d[, c(list(c1=c1, c2=c2), list(v3=v3), list(v4=v4, v5=v5)), env=list(v3=v3,v4=v4,v5=v5)], d) ## d[, c(list(c1, c2), list(get(v3)), mget(c(v4,v5)))] - some are unnamed

# use DT[, var, env=list(var=quote(.(sum_x=sum(x)))] rather than dt[, eval(var)]?
#TODO

# contributed use cases
#TODO
